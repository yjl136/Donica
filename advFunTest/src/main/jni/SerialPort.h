/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_advantech_advfuntest_SerialPort */

#ifndef _Included_com_advantech_advfuntest_SerialPort
#define _Included_com_advantech_advfuntest_SerialPort
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_advantech_advfuntest_SerialPort
 * Method:    open
 * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor;
 */
JNIEXPORT jobjectJNICALL
Java_com_advantech_advfuntest_SerialPort_open
(JNIEnv
*, jclass, jstring, jint, jint);

/*
 * Class:     com_advantech_advfuntest_SerialPort
 * Method:    close
 * Signature: ()V
 */
JNIEXPORT void JNICALL
Java_com_advantech_advfuntest_ExecCmd_close
(JNIEnv
*, jobject);

/*
 * Class:     com_advantech_advfuntest_ExecCmd
 * Method:    flash_to_file
 * Signature: ()V
 */
JNIEXPORT void JNICALL
Java_com_advantech_advfuntest_ExecCmd_flash_1to_1file
(JNIEnv
*, jclass);

/*
 * Class:     com_advantech_advfuntest_ExecCmd
 * Method:    frabuffer_rgb
 * Signature: ()V
 */
JNIEXPORT void JNICALL
Java_com_advantech_advfuntest_SerialPort_frabuffer_1rgb
(JNIEnv
*, jclass);


struct fb_var_screeninfo vinfo;
struct fb_fix_screeninfo finfo;
char *frameBuffer = 0;

//画大小为width*height的同色矩阵，8alpha+8reds+8greens+8blues
void drawRect_rgb32(int x0, int y0, int width, int height, int color) {
    const int bytesPerPixel = 4;
    const int stride = finfo.line_length / bytesPerPixel;

    int *dest = (int *) (frameBuffer)
                + (y0 + vinfo.yoffset) * stride + (x0 + vinfo.xoffset);

    int x, y;
    for (y = 0; y < height; ++y) {
        for (x = 0; x < width; ++x) {
            dest[x] = color;
        }
        dest += stride;
    }
}

//画大小为width*height的同色矩阵，5reds+6greens+5blues
void drawRect_rgb16(int x0, int y0, int width, int height, int color) {
    const int bytesPerPixel = 2;
    const int stride = finfo.line_length / bytesPerPixel;
    const int red = (color & 0xff0000) >> (16 + 3);
    const int green = (color & 0xff00) >> (8 + 2);
    const int blue = (color & 0xff) >> 3;
    const short color16 = blue | (green << 5) | (red << (5 + 6));

    short *dest = (short *) (frameBuffer)
                  + (y0 + vinfo.yoffset) * stride + (x0 + vinfo.xoffset);

    int x, y;
    for (y = 0; y < height; ++y) {
        for (x = 0; x < width; ++x) {
            dest[x] = color16;
        }
        dest += stride;
    }
}

//画大小为width*height的同色矩阵，5reds+5greens+5blues
void drawRect_rgb15(int x0, int y0, int width, int height, int color) {
    const int bytesPerPixel = 2;
    const int stride = finfo.line_length / bytesPerPixel;
    const int red = (color & 0xff0000) >> (16 + 3);
    const int green = (color & 0xff00) >> (8 + 3);
    const int blue = (color & 0xff) >> 3;
    const short color15 = blue | (green << 5) | (red << (5 + 5)) | 0x8000;

    short *dest = (short *) (frameBuffer)
                  + (y0 + vinfo.yoffset) * stride + (x0 + vinfo.xoffset);

    int x, y;
    for (y = 0; y < height; ++y) {
        for (x = 0; x < width; ++x) {
            dest[x] = color15;
        }
        dest += stride;
    }
}

void drawRect(int x0, int y0, int width, int height, int color) {
    switch (vinfo.bits_per_pixel) {
        case 32:
            drawRect_rgb32(x0, y0, width, height, color);
            break;
        case 16:
            drawRect_rgb16(x0, y0, width, height, color);
            break;
        case 15:
            drawRect_rgb15(x0, y0, width, height, color);
            break;
        default:
            printf("Warning: drawRect() not implemented for color depth %i\n",
                   vinfo.bits_per_pixel);
            break;
    }
}

#ifdef __cplusplus
}
#endif
#endif
